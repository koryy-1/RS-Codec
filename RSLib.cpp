#include "RSLib.h"
#include <math.h>

using namespace std;

int m; // степень RS-полинома
int n; // n = 2 ** m - 1 (длина кодового слова)
int t; // количество ошибок, которые мы хотим скорректировать
int k; // k = n - 2 * t (длина информационного слова)


int* p; // неприводимый полином
int* g; // порождающий полином
int* alpha_to; //таблица степеней примитивного члена
int* index_of; //индексная таблица для быстрого умножения

void calc_n_k(int mm, int tt, int& nn, int& kk)
{
    nn = pow(2, mm) - 1;
    kk = nn - 2 * tt;
}

void set_m_t_p(int mm, int tt, int* pp)
{
    m = mm;
    t = tt;
    calc_n_k(m, t, n, k);
    /*n = pow(2, m) - 1;
    k = n - 2 * t;*/
    //p = pp;
    p = new int[m + 1];
    for (int i = 0; i < m + 1; i++)
    {
        p[i] = pp[i];
    }
    alpha_to = new int[n + 1];
    index_of = new int[n + 1];
    g = new int[n - k + 1];
}

int *generate_gf(int* l_alpha_to, int* l_index_of)
{
    //----------------------------------------------------------------------------
    // генерируем look-up таблицу для GF(2 ^ m) на основе
    // несократимого порождающего полинома Pc от p[0] до p[m].
    //
    // look-up таблица:
    // index->polynomial из alpha_to[] содержит j = alpha ^ i,
    // где alpha есть примитивный член, обычно равный 2
    // а ^ - операция возведения в степень (не XOR!);
    //
    // polynomial form -> index из index_of[j = alpha ^ i] = i;
    //----------------------------------------------------------------------------

    int i, mask;

    mask = 1; alpha_to[m] = 0;

    for (i = 0; i < m; i++)
    {
        alpha_to[i] = mask;
        index_of[alpha_to[i]] = i;

        if (p[i] != 0) alpha_to[m] ^= mask;
        mask <<= 1;
    }
    index_of[alpha_to[m]] = m;
    mask >>= 1;

    for (i = m + 1; i < n; i++)
    {
        if (alpha_to[i - 1] >= mask)
            alpha_to[i] = alpha_to[m] ^ ((alpha_to[i - 1] ^ mask) << 1);
        else
            alpha_to[i] = alpha_to[i - 1] << 1;

        index_of[alpha_to[i]] = i;
    }
    index_of[0] = -1;

    for (int i = 0; i < n; i++)
    {
        l_alpha_to[i] = alpha_to[i];
        l_index_of[i] = index_of[i];
    }
    
    return l_alpha_to;
}

int *gen_poly()
{
    register int i, j;

    g[0] = 2;    /* primitive element alpha = 2  for GF(2**mm)  */
    g[1] = 1;    /* g(x) = (X+alpha) initially */
    for (i = 2; i <= n - k; i++)
    {
        g[i] = 1;
        for (j = i - 1; j > 0; j--)
            if (g[j] != 0)  g[j] = g[j - 1] ^ alpha_to[(index_of[g[j]] + i) % n];
            else g[j] = g[j - 1];
        g[0] = alpha_to[(index_of[g[0]] + i) % n];     /* g[0] can never be zero */
    }
    /* convert g[] to index form for quicker encoding */
    for (i = 0; i <= n - k; i++)  g[i] = index_of[g[i]];
    return g;
}

/*-----------------------------------------------------------------------------------------------------

*                           кодер Рида-Соломона

*                           ========================

* кодируемые данные передаются через массив data[i], где i=0..(k-1), а сгенерированные символы четности

* заносятся в массив b[0]..b[2*t-1]. Исходные и результирующие данные должны быть представлены

* в полиномиальной форме (т.е. в обычной форме машинного представления данных).

* Кодирование производится с использованием сдвигового feedback-регистра, заполненного соответствующими

* элементами массива g[] с порожденным полиномом внутри. Сгенерированное кодовое слово описывается следующей формулой:

* с(x) = data(x)*x^(n-k) + b(x)

–––––––––––––––––––––––––––––––––––––––––––––––––––––––––---------------------------------------------*/
int *encode_rs(int* inf_data, int* b)
{
    int i, j;

    int feedback;

    for (i = 0; i < n - k; i++) b[i] = 0;

    // обрабатываем все символы исходных данных справа налево

    for (i = k - 1; i >= 0; i--)

    {

        // готовим (data[i] + b[n – k –1]) к умножению на g[i], т.е. складываем очередной «захваченный»

        // символ исходных данных с младшим символом битов четности (соответствующего «регистру» b2t-1,

        // и переводим его в индексную форму, сохраняя результат в регистре feedback,

        // сумма двух индексов есть произведение полиномов

        feedback = index_of[inf_data[i] ^ b[n - k - 1]];

        // есть еще символы для обработки?

        if (feedback != -1)
        {

            // осуществляем сдвиг цепи bx-регистров

            for (j = n - k - 1; j > 0; j--)

                // если текущий коэффициент g – это действительный (т.е. ненулевой коэффициент,

                // то умножаем feedback на соответствующий g-коэффициент и складываем его

                // со следующим элементом цепочки

                if (g[j] != -1) //ї

                    b[j] = b[j - 1] ^ alpha_to[(g[j] + feedback) % n];

                else

                    // если текущий коэффициент g – это нулевой коэффициент, выполняем один лишь

                    // сдвиг без умножения, перемещая символ из одного m-регистра в другой

                    b[j] = b[j - 1];

            // закольцовываем выходящий символ в крайний левый b0-регистр

            b[0] = alpha_to[(g[0] + feedback) % n];

        }
        else
        {  // деление завершено, осуществляем последний сдвиг регистра, на выходе регистра

           // будет частное, которое теряется, а в самом регистре – искомый остаток

            for (j = n - k - 1; j > 0; j--) b[j] = b[j - 1]; b[0] = 0;

        }

    }

    return b;
}

/*-----------------------------------------------------------------------------------------------------

*                                     декодер Рида-Соломона

*                                     =====================

* Процедура декодирования кодов Рида-Соломона состоит из нескольких шагов: сначала мы вычисляем

* 2t-символьный синдром путем постановки alpha**i в recd(x), где recd – полученное кодовое слово,

* предварительно переведенное в индексную форму. По факту вычисления recd(x) мы записываем

* очередной символ синдрома в s[i], где i принимает значение от 1 до 2t, оставляя s[0] равным нулю.

* Затем, используя итеративный алгоритм Берлекэмпа, мы находим полином локатора ошибки – elp[i].

* Если степень elp превышает собой величину t, мы бессильны скорректировать все ошибки и ограничиваемся

* выводом сообщения о неустранимой ошибке, после чего совершаем аварийный выход из декодера.

* Если же степень elp не превышает t, мы подставляем alpha**i, где i = 1..n в elp для вычисления

* корней полинома. Обращение найденных корней дает нам позиции искаженных символов. Если количество

* определенных позиций искаженных символов меньше степени elp, искажению подверглось более чем t

* символов и мы не можем восстановить их. Во всех остальных случаях восстановление оригинального

* содержимого искаженных символов вполне возможно. В случае, когда количество ошибок заведомо велико,

* для их исправления декодируемые символы проходят сквозь декодер без каких-либо изменений.

–––––––––––––––––––––––––––––––––––––––––––––––––––––––––--------------------------------------------*/

int *decode_rs(int* recd)
{
    int i, j, u, q;

    //int s[n - k + 1];              // полином синдрома ошибки
    int* s = new int[n - k + 1];

    //int elp[n - k + 2][n - k]; // полином локатора ошибки лямбда
    int** elp = new int* [n - k + 2];
    for (size_t i = 0; i < n - k + 2; i++)
    {
        elp[i] = new int[n - k];
    }

    //int d[n - k + 2];
    int* d = new int[n - k + 2];

    //int l[n - k + 2];
    int* l = new int[n - k + 2];

    //int u_lu[n - k + 2];
    int* u_lu = new int[n - k + 2];

    int count = 0, syn_error = 0;/* root[t], loc[t], z[t + 1], err[n], reg[t + 1];*/
    int* root = new int[t];
    int* loc = new int[t];
    int* z = new int[t + 1];
    int* err = new int[n];
    int* reg = new int[t + 1];


    // переводим полученное кодовое слово в индексную форму для упрощения вычислений

    for (i = 0; i < n; i++) recd[i] = index_of[recd[i]];

    // вычисляем синдром

    //-------------------------------------------------------------------------------------------------

    for (i = 1; i <= n - k; i++)
    {

        s[i] = 0;     // инициализация s-регистра (на его вход по умолчанию поступает ноль)   

        // выполняем s[i] += recd[j]*ij т.е. берем очередной символ декодируемых данных, умножаем его

        // на порядковый номер данного символа, умноженный на номер очередного оборота и складываем

        // полученный результат с содержимым s-регистра по факту исчерпания всех декодируемых символов,

        // мы повторяем весь цикл вычислений опять – по одному разу для каждого символа четности

        for (j = 0; j < n; j++) if (recd[j] != -1) s[i] ^= alpha_to[(recd[j] + i * j) % n];

        if (s[i] != 0) syn_error = 1;  // если синдром не равен нулю, взводим флаг ошибки   

        // преобразуем синдром из полиномиальной формы в индексную

        s[i] = index_of[s[i]];

    }

    // коррекция ошибок

    //-------------------------------------------------------------------------------------------------

    if (syn_error)     // если есть ошибки, пытаемся их скорректировать
    {

        // вычисление полинома локатора лямбда

        //-----------------------------------------------------------------------------------------------

        // вычисляем полином локатора ошибки через итеративный алгоритм Берлекэмпа. Следуя терминологии

       // Lin and Costello (см. "Error Control Coding: Fundamentals and Applications" Prentice Hall 1983

       // ISBN 013283796) d[u] представляет собой m («мю»), выражающую расхождение (discrepancy),

       // где u = m + 1 и m есть номер шага из диапазона от –1 до 2t. У Блейхута та же самая величина

       // обозначается D(x) («дельта») и называется невязкой. l[u] представляет собой степень elp

       // для данного шага итерации, u_l[u] представляет собой разницу между номером шага и степенью elp,

        // инициализируем элементы таблицы

        d[0] = 0;        // индексная форма

        d[1] = s[1];    // индексная форма

        elp[0][0] = 0;  // индексная форма

        elp[1][0] = 1;  // полиномиальная форма   

        for (i = 1; i < n - k; i++)
        {

            elp[0][i] = -1; // индексная форма

            elp[1][i] = 0;  // полиномиальная форма

        }

        l[0] = 0; l[1] = 0; u_lu[0] = -1; u_lu[1] = 0; u = 0;

        do
        {

            u++;

            if (d[u] == -1)
            {

                l[u + 1] = l[u];

                for (i = 0; i <= l[u]; i++)
                {

                    elp[u + 1][i] = elp[u][i];

                    elp[u][i] = index_of[elp[u][i]];

                }

            }
            else
            {

                // поиск слов с наибольшим u_lu[q], таких что d[q]!=0

                q = u - 1;

                while ((d[q] == -1) && (q > 0)) q--;



                // найден первый ненулевой d[q]

                if (q > 0)
                {

                    j = q;

                    do
                    {

                        j--;

                        if ((d[j] != -1) && (u_lu[q] < u_lu[j]))

                            q = j;

                    } while (j > 0);

                };

                // как только мы найдем q, такой что d[u]!=0 и u_lu[q] есть максимум

                // запишем степень нового elp полинома

                if (l[u] > l[q] + u - q) l[u + 1] = l[u]; else l[u + 1] = l[q] + u - q;

                // формируем новый elp(x)

                for (i = 0; i < n - k; i++) elp[u + 1][i] = 0;

                for (i = 0; i <= l[q]; i++)

                    if (elp[q][i] != -1)

                        elp[u + 1][i + u - q] = alpha_to[(d[u] + n - d[q] + elp[q][i]) % n];

                for (i = 0; i <= l[u]; i++)
                {

                    elp[u + 1][i] ^= elp[u][i];

                    // преобразуем старый elp в индексную форму

                    elp[u][i] = index_of[elp[u][i]];

                }

            }

            u_lu[u + 1] = u - l[u + 1];

            // формируем (u + 1) невязку

            //------------------------------------------------------------------------------------------------

            if (u < n - k)  // на последней итерации расхождение не было обнаружено
            {

                if (s[u + 1] != -1) d[u + 1] = alpha_to[s[u + 1]]; else d[u + 1] = 0;

                for (i = 1; i <= l[u + 1]; i++)

                    if ((s[u + 1 - i] != -1) && (elp[u + 1][i] != 0))

                        d[u + 1] ^= alpha_to[(s[u + 1 - i] + index_of[elp[u + 1][i]]) % n];

                // переводим d[u+1] в индексную форму

                d[u + 1] = index_of[d[u + 1]];

            }

        } while ((u < n - k) && (l[u + 1] <= t));

        // расчет локатора завершен

        //-----------------------------------------------------

        u++;

        if (l[u] <= t)
        {  // коррекция ошибок возможна



          // переводим elp в индексную форму

            for (i = 0; i <= l[u]; i++) elp[u][i] = index_of[elp[u][i]];

            // нахождение корней полинома локатора ошибки

            //----------------------------------------------

            for (i = 1; i <= l[u]; i++) reg[i] = elp[u][i]; count = 0;

            for (i = 1; i <= n; i++)
            {

                q = 1;

                for (j = 1; j <= l[u]; j++)

                    if (reg[j] != -1)
                    {

                        reg[j] = (reg[j] + j) % n;

                        q ^= alpha_to[reg[j]];

                    }

                if (!q)
                {  // записываем корень и индекс позиции ошибки

                    root[count] = i;

                    loc[count] = n - i;

                    count++;

                }

            }

            if (count == l[u])
            {       // нет корней – степень elp < t ошибок   

               // формируем полином z(x)

                for (i = 1; i <= l[u]; i++) // Z[0] всегда равно 1
                {

                    if ((s[i] != -1) && (elp[u][i] != -1))

                        z[i] = alpha_to[s[i]] ^ alpha_to[elp[u][i]];

                    else

                        if ((s[i] != -1) && (elp[u][i] == -1))

                            z[i] = alpha_to[s[i]];

                        else

                            if ((s[i] == -1) && (elp[u][i] != -1))

                                z[i] = alpha_to[elp[u][i]];

                            else

                                z[i] = 0;

                    for (j = 1; j < i; j++)

                        if ((s[j] != -1) && (elp[u][i - j] != -1))

                            z[i] ^= alpha_to[(elp[u][i - j] + s[j]) % n];

                    // переводим z[i] в индексную форму

                    z[i] = index_of[z[i]];

                }

                // вычисление значения ошибок в позициях loc[i]

                //----------------------------------------------------------------------------------------------

                for (i = 0; i < n; i++)
                {

                    err[i] = 0;

                    // переводим recd[] в полиномиальную форму

                    if (recd[i] != -1) recd[i] = alpha_to[recd[i]]; else recd[i] = 0;

                }

                // сначала вычисляем числитель ошибки

                for (i = 0; i < l[u]; i++)
                {

                    err[loc[i]] = 1;

                    for (j = 1; j <= l[u]; j++)

                        if (z[j] != -1)

                            err[loc[i]] ^= alpha_to[(z[j] + j * root[i]) % n];

                    if (err[loc[i]] != 0)
                    {

                        err[loc[i]] = index_of[err[loc[i]]];

                        q = 0; // формируем знаменатель коэффициента ошибки

                        for (j = 0; j < l[u]; j++)

                            if (j != i)

                                q += index_of[1 ^ alpha_to[(loc[j] + root[i]) % n]];

                        q = q % n; err[loc[i]] = alpha_to[(err[loc[i]] - q + n) % n];

                        // recd[i] должен быть в полиномиальной форме

                        recd[loc[i]] ^= err[loc[i]];

                    }

                }

            }
            else // нет корней, решение системы уравнений невозможно, т.к. степень elp >= t
            {

                // переводим recd[] в полиномиальную форму

                for (i = 0; i < n; i++)

                    if (recd[i] != -1) recd[i] = alpha_to[recd[i]];

                    else

                        recd[i] = 0;  // выводим информационное слово как есть

            }
        }
        else            // степень elp > t, решение невозможно
        {

            // переводим recd[] в полиномиальную форму

            for (i = 0; i < n; i++)

                if (recd[i] != -1)

                    recd[i] = alpha_to[recd[i]];

                else

                    recd[i] = 0; // выводим информационное слово как есть

        }
    }
    else { // ошибок не обнаружено
        for (i = 0; i < n; i++) if (recd[i] != -1)recd[i] = alpha_to[recd[i]]; else recd[i] = 0;

    }
    delete[] s;
    for (size_t i = 0; i < n - k + 2; i++)
    {
        delete[] elp[i];
    }
    delete[] elp;
    delete[] d;
    delete[] l;
    delete[] u_lu;
    delete[] root;
    delete[] loc;
    delete[] z;
    delete[] err;
    delete[] reg;

    return recd;
}
